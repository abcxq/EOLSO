
%%%This program calculates SSE, MAE, RMSE, and MaxAE based on parameters generated by main_1
%%%%  This program was developed by Wuke Li  , Ying Xiong 

clc;
clear;
close all;
rng('default');

% 加载数据
load('data_plus.mat');    % 放电数据
load('OCV_SOC.mat');      % OCV-SOC 关系
load('results.mat');      % 各算法辨识的参数结果

% 提取电压、电流、SOC 数据
data_plus = data_plus(:, 1:70000);
U = data_plus(3, :);      % 实际电压
Ii = data_plus(2, :);     % 电流
SOC = data_plus(4, :);    % SOC 实际值（通过安时法计算得到）

% 拟合 OCV-SOC 曲线，使用 8 次多项式
x = OCV_SOC(2, :);
y = OCV_SOC(1, :);
p = polyfit(x, y, 8);

% 设置仿真参数
N1 = length(Ii);
Ts = 1;
ocv = zeros(1, N1);
ocv(1) = U(1);
for i = 2:N1
    ocv(i) = polyval(p, SOC(i));
end
L = size(Ii, 2);

% 初始化变量
U_duan = zeros(1, L);       % 六种算法的仿真电压
X_error = zeros(1, L);      % 六种算法的误差
RMSE = zeros(1, 1);         % 六种算法的 RMSE
SSE_V2 = zeros(1, 1);       % 六种算法的 SSE/V^2
MAE = zeros(1, 1);          % 六种算法的 MAE
MaxAE = zeros(1, 1);        % 六种算法的 MaxAE

% 获取六种算法的参数
R0_mean = results.R0;       % 从 results.mat 中加载 R0 平均值
R1 = results.R1;
R2 = results.R2;
C1 = results.C1;
C2 = results.C2;

% 算法名称
algorithm_names = {'EOLSO', 'ESO', 'SO', 'GJO', 'HBA', 'GWO'};

% 逐个算法进行仿真
for alg = 1:1
    % 初始化状态变量
    u1 = 0;
    u2 = 0;
    % 获取当前算法的参数
    R0_alg = R0_mean;   % R0 取平均值
    R1_alg = R1(alg);
    R2_alg = R2(alg);
    C1_alg = C1(alg);
    C2_alg = C2(alg);
    
    % 仿真计算
    for k = 1:L
        u1 = exp(-Ts / (R1_alg * C1_alg)) * u1 + R1_alg * (1 - exp(-Ts / (R1_alg * C1_alg))) * Ii(k);
        u2 = exp(-Ts / (R2_alg * C2_alg)) * u2 + R2_alg * (1 - exp(-Ts / (R2_alg * C2_alg))) * Ii(k);
        UL = ocv(k) + Ii(k) * R0_alg + u1 + u2;
        U_duan(alg, k) = UL;
        X_error(alg, k) = U(k) - UL;
    end
    % 计算误差指标
    RMSE(alg) = sqrt(mean((X_error(alg, :)).^2));
    SSE = sum((X_error(alg, :)).^2);
    V_nominal = mean(U);  % 以平均电压作为标称电压
    SSE_V2(alg) = SSE / (V_nominal^2);
    MAE(alg) = mean(abs(X_error(alg, :)));
    MaxAE(alg) = max(abs(X_error(alg, :)));
end

% 绘制实际电压与各算法仿真电压的对比图
figure;
plot(U, '-k', 'LineWidth', 1.5); hold on;
colors = {'-r', '--b', '-.g', ':k', '-m', '--c'};
for alg = 1:1
    plot(U_duan(alg, :), colors{alg}, 'LineWidth', 1);
end
xlabel('Time/s','FontSize', 16);
ylabel('Voltage (V)','FontSize', 16');
ax = gca; 
ax.XAxis.Exponent = 0;   % 禁止科学计数法
set(gca, 'FontSize', 13);
%title('实际电压与各算法仿真电压对比');
legend_names = [{'Measured'}, algorithm_names];
legend(legend_names, 'Location', 'Best');
grid on;

% 绘制各算法的误差曲线
figure;
for alg = 1:1
    plot(X_error(alg, :), colors{alg}, 'LineWidth', 1); hold on;
end
xlabel('Time/s','FontSize', 16);
ylabel('Errors/V','FontSize', 16);
ax = gca; 
ax.XAxis.Exponent = 0;   % 禁止科学计数法
set(gca, 'FontSize', 13);
%title('各算法的误差曲线对比');
legend(algorithm_names, 'Location', 'Best');
grid on;

% 显示各算法的误差指标
fprintf('各算法的误差指标：\n');
for alg = 1:1
    fprintf('%s:\n', algorithm_names{alg});
    fprintf('  RMSE    = %.6f V\n', RMSE(alg));
    fprintf('  SSE/V^2 = %.6f\n', SSE_V2(alg));
    fprintf('  MAE     = %.6f V\n', MAE(alg));
    fprintf('  MaxAE   = %.6f V\n\n', MaxAE(alg));
end

